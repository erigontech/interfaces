syntax = "proto3";

package sentinel;

option go_package = "./sentinel;sentinel";

import "types/types.proto";

message EmptyMessage {}

enum GossipType {
    // Lightclient gossip
    LIGHT_CLIENT_FINALITY_UPDATE_GOSSIP_TYPE = 0;
    LIGHT_CLIENT_OPTIMISTIC_UPDATE_GOSSIP_TYPE = 1;
    // Legacy gossip
    BEACON_BLOCK_GOSSIP_TYPE = 2;
    
    // Global gossip topics.
    AGGREGATE_AND_PROOF_GOSSIP_TYPE = 3;
    VOLUNTARY_EXIT_GOSSIP_TYPE = 4;
    PROPOSER_SLASHING_GOSSIP_TYPE = 5;
    ATTESTER_SLASHING_GOSSIP_TYPE = 6;
}

message GossipData {
    bytes data = 1; // SSZ encoded data
    GossipType type = 2;
}

message Status {
    uint32 fork_digest = 1; // 4 bytes can be repressented in uint32.
    types.H256 finalized_root = 2;
    uint64 finalized_epoch = 3;
    types.H256 head_root = 4;
    uint64 finalized_epoch = 5;
}

message PeerCount {
    uint64 amount = 1;
}

message RequestData {
    bytes data = 1; // SSZ encoded data
    string topic = 2;
}

message ResponseData {
    bytes data = 1; // prefix-stripped SSZ encoded data
    bool error = 2; // did the peer encounter an error
}

service Sentinel {
    rpc SubscribeGossip(EmptyMessage) returns (stream GossipData);
    rpc SendRequest(RequestData) returns (ResponseData);
    rpc SetStatus(Status) returns(EmptyMessage); // Set status for peer filtering.
    rpc GetPeers(EmptyRequest) returns (PeerCount);
}
